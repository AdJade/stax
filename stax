#! /bin/bash
#####################################################################
#   stax - builds a VPC in AWS - https://github.com/philcryer/stax
#   https://github.com/philcryer/stax/blob/master/LICENSE
#   this should work(tm)!                                  2015/01
#####################################################################

# variables
pkg="stax"
version="0.4"
STAX_PRE_NAME="stax"
SCRIPT_PATH=$(cd $(dirname $0); pwd -P)
SYSTEM=$(uname)
STAX_DIR="$SCRIPT_PATH/run"
STAX_NAME_FILE="$STAX_DIR/stax-name"
STAX_LOG="$STAX_DIR/stax.log"
SSH_OPTIONS="-q"
host=$(hostname)
YES=

# make sure we are running under ssh-agent
if [[ ! $SSH_AUTH_SOCK ]]; then
    echo "$pkg: not running under ssh-agent, restarting with ssh-agent running"
    exec ssh-agent $0 "$@"
fi

# create a dir to store stax stuff
if [[ ! -d $STAX_DIR ]]; then
    if ! mkdir -p "$STAX_DIR"; then
        echo "$pkg: failed to make run directory: $STAX_DIR"
        exit 1
    fi
    if ! chmod 700 "$STAX_DIR"; then
        echo "$pkg: failed to chmod $STAX_DIR"
        exit 1
    fi
fi
# create audit dir for stax
if [[ ! -d $STAX_DIR/audit ]]; then
    if ! mkdir -p "$STAX_DIR/audit"; then
        echo "$pkg: failed to make audit directory: $STAX_DIR/audit"
        exit 1
    fi
fi

# set colors
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
purple=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
reset=$(tput sgr0)

stax-message(){
    msg="$1"
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo "${yellow}[ $cyan$pref$yellow ]$reset  $msg"
    stax-logger "INFO: $msg"
}

stax-error(){
    msg="$1"
    echo "${yellow}[ ${red}ERRR$yellow ]$reset  $msg"
    stax-logger "ERROR: $msg"
}

stax-error-exit(){
    msg="$1"
    status="$2"
    stax-error "$msg"
    exit $status
}

stax-logger(){
    msg="$1"
    if [[ ! $STAX_LOG ]]; then
        echo "$pkg: cannot call stax-logger with STAX_LOG undefined"
        exit 5
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$STAX_LOG"
}

stax-usage(){
    cat <<EOM
Usage: stax [OPTIONS] <command>

Options:
  -c,--config=CONFIG       Use file CONFIG rather than config/config.json
  -d,--debug               Turn on verbose messages
  -h,--help                Output this message
  -j,--jump=IP             SSH through host with IP address IP
  -t,--template=TEMPLATE   Use file TEMPLATE rather than templates/default.json
  -v,--version             Print name and version information
  -y,--yes                 Do not prompt for confirmation

If an argument is required for a long option, so to the short. Same for
optional arguments.

Commands:
  add                Add functionality to an existing VPC
  connect [target]   Connect to jump|gateway|service in the VPC stax over SSH
  create             Create a new VPC stax in AWS
  describe           Describe the stax created from this host
  destroy            Destroy the existing VPC stax
  dockerip-update    Fetch docker IP addresses and update related files
  fleet              Run various fleetctl commands against the fleet cluster
  generate           Regenerate the VPC template from the Scala definition
  help               Output this message
  history            View history of recently created/destroyed stax
  list               List all completely built and running stax
  services           List servers that are available to run across a stax
  start <service>    Start a service across the stax cluster
  test               Automated test to exercise functionality of stax
  validate           Validate CloudFormation template

For more help, check the docs: https://github.com/philcryer/stax
EOM
}

## FIXME broken or unused commands, fix or remove?
#desc-auto         Describe the autoscaling groups in the stax

stax-logo(){
NUMS=`wc -l < assets/stax/slogans`
    echo "${green}     _             "
    echo "    | | ${yellow}`head -$((${RANDOM} % ${NUMS} + 1)) assets/stax/slogans | tail -1`${green}"
    echo " ___| |_ __ ___  __"
    echo '/ __| __/ _` \ \/ /'
    echo '\__ \ || (_| |>  < '
    echo "|___/\__\__,_/_/\_\ ${reset} `echo $version`"
    echo
}

stax-preflight(){
    # check for required cli tools
    for cli in aws ssh; do
        if ! type "$cli" > /dev/null 2>&1; then
            stax-error-exit "$pkg: $cli is not in the PATH. Aborting." 1
        fi
    done
    # check if awscli tools are configured
    if [[ ! -f $HOME/.aws/config ]]; then
        stax-error-exit "awscli not configured, run 'aws configure'. Aborting." 1
    fi
    # check for jq, use system installed version if found, otherwise use bundled
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$SYSTEM/jq"
        if [[ ! -f $jq ]]; then
            stax-error-exit "no viable jq binary found, Aborting." 1
        fi
    fi
}

stax-generate-template(){
    stax-message "generating the VPC template from the low-level Scala DSL"
    if ! sbt run; then
        stax-error-exit "failed to generate template" 1
    fi
    stax-message "  vpc template successfully generated"
}

stax-create-key(){
    stax-message "creating ssh key pair in aws"
    STAX_KEY="$STAX_NAME"
    STAX_PRIV_KEY="$STAX_DIR/$STAX_NAME.pem"
    touch "$STAX_PRIV_KEY"
    chmod 600 "$STAX_PRIV_KEY"
    stax-message "  creating key pair"
    if ! aws ec2 create-key-pair --key-name "$STAX_NAME" --query 'KeyMaterial' --output text > "$STAX_PRIV_KEY"; then
        stax-error "failed to create key pair in aws"
        return 1
    fi
    stax-message "  key pair created"
    stax-message "  generating public key"
    STAX_PUB_KEY="$STAX_PRIV_KEY.pub"
    if ! ssh-keygen -y -f "$STAX_PRIV_KEY" > "$STAX_PUB_KEY"; then
        stax-error "failed to generate public key from private key: $STAX_PRIV_KEY $STAX_PUB_KEY"
        stax-destroy-key
        return 1
    fi
    stax-message "  public key generated"
    if ! stax-ssh-key-add; then
        stax-error "failed to add ssh key to ssh-agent, connecting to hosts may not work properly"
        return 0
    fi
}

stax-create-bucket(){
    stax-message "create bucket"
    bucket="$STAX_NAME"
    if [[ $1 ]]; then
        bucket="$1"
    fi
    if [[ ! $bucket ]]; then
        stax-error-exit "you must supply the name for the bucket to be created" 5
    fi
    stax-message "  creating bucket $bucket"
    if ! aws s3 mb "s3://$bucket" > /dev/null; then
        stax-error "failed to create bucket: $bucket"
        return 1
    fi
    stax-message "  created bucket $bucket"
}

stax-upload-template(){
    if [[ ! $1 ]]; then
        stax-error-exit "stax-upload-template requires the template path as an argument" 10
    fi
    template_path="$1"
    if [[ ! -f $template_path ]]; then
        stax-error "template file not found: $template_path"
        return 1
    fi
    template="$STAX_NAME/$STAX_NAME.json"
    stax-message "  uploading template"
    if ! aws s3 cp "$template_path" "s3://$template" > /dev/null; then
        stax-error "failed to copy $template_path to s3"
        return 1
    fi
    STAX_TEMPLATE_URL="https://s3.amazonaws.com/$template"
    stax-message "  template uploaded to $STAX_TEMPLATE_URL"
}

stax-validate-template(){
    stax-message "validate template"
    if [[ ! $STAX_TEMPLATE_URL ]]; then
        stax-error "cannot call stax-validate-template without defining STAX_TEMPLATE_URL first"
        stax-error "call stax-upload-template first"
        return 10
    fi
    template="$STAX_TEMPLATE_URL"
    stax-message "  validating template $template"
    if ! aws cloudformation validate-template --template-url "$template" > /dev/null; then
        stax-error "template failed to validate, exiting"
        return 1
    fi
    stax-message "  validated template $template"
}

stax-validate(){
    stax-message "validate template"
    if [[ ! $1 ]]; then
        stax-error "stax-validate requires the template path as an argument"
        return 10
    fi
    template_path="$1"
    if ! stax-generate; then
        stax-error "failed to set up stax"
        return 1
    fi
    if ! $jq . "$template_path" >/dev/null; then
        stax-error "template $template_path failed jq validation, see error above"
        return 1
    fi
    if ! stax-create-bucket; then
        stax-error "failed to create bucket for upload"
        return 1
    fi
    if ! stax-upload-template "$template_path"; then
        stax-destroy-bucket
        stax-error "failed to upload template"
        return 1
    fi
    if ! stax-validate-template; then
        stax-destroy-bucket
        stax-error "failed to validate template"
        return 1
    fi
    if ! stax-destroy-bucket; then
        stax-error "failed to delete bucket, please do so manually"
        return 1
    fi
}

stax-add(){
    stax-message "Adding RDS to existing vpc"
    stax-message "  getting existing VPC name"
    vpc_id=$(jq --raw-output '.Stacks[].Outputs[] | select(.OutputKey=="VPCID").OutputValue' "$STAX_DIR/$STAX_NAME.json")
    echo $vpc_id > $STAX_DIR/$STAX_NAME.vpc
    # build RDS params file"
    stax-message "  building params file"
    stax-rds-config
    stax-message "  getting existing VPC name"
    stax-message "  adding to `cat $STAX_DIR/$STAX_NAME.vpc`"

    ####################################################
    # new routine replaces @VPC_ID@ in the rds template
    ####################################################
    template_path="$1"
    old_template_path=$1
    template_path="run/`echo $1 | cut -d"/" -f2`"
    sed="sed -e s/@VPC_ID@/$vpc_id/"
    if ! $sed "$old_template_path" > "$template_path"; then
        stax-error "sed failed to replace elements in $config: $sed"
        return 1
    fi
    ####################################################
    #  (this could (probably) be done a bit better...)
    ####################################################

    if ! stax-upload-template "$template_path"; then
        stax-error-exit "failed to upload template to s3" 1
    fi
    if ! stax-validate-template; then
        stax-error-exit "failed to validate template" 1
    fi

    stax-message "Creating RDS stax in $vpc_id"
    # create/add RDS to existing VPC
    if ! aws cloudformation create-stack \
        --stack-name "$STAX_NAME-RDS" \
        --template-url "$STAX_TEMPLATE_URL" \
        --parameters "$(<$STAX_RDS_PARAMS)" \
        --capabilities CAPABILITY_IAM > /dev/null
    then
        stax-error-exit "creation failed, exiting" 1
    fi
    stax-message "  stax creation complete"
    touch "$STAX_DIR/audit/$STAX_NAME-RDS/$(date +'%Y%m%d-%H%M%S')-created"
    stax-describe
    exit 0
}

stax-destroy-rds(){
    stax-message "Destroying RDS"
    STAX_RDS_PARAMS="$STAX_DIR/$STAX_NAME.rdsparams"
    # delete RDS from existing VPC
    #--template-url "$STAX_TEMPLATE_URL" \
    #    --capabilities CAPABILITY_IAM > /dev/null
    #    --parameters "$(<$STAX_RDS_PARAMS)" \
    if ! aws cloudformation delete-stack \
        --stack-name "$STAX_NAME-RDS" 
    then
        stax-error-exit "  RDS delete failed, exiting" 1
    fi
    stax-message "  RDS delete complete"
    touch "$STAX_DIR/audit/$STAX_NAME-RDS/$(date +'%Y%m%d-%H%M%S')-destroyed"
}

stax-create(){
    stax-message "creating stax"
    if [[ ! $1 ]]; then
        stax-error-exit "stax-create takes the template path as an argument" 10
    fi
    template_path="$1"
    if [[ -f $STAX_NAME_FILE ]]; then
        existing_name=$(<$STAX_NAME_FILE)
        stax-error "existing stax defined: $existing_name"
        stax-error-exit "currently having only one stack is supportetd, exiting" 1
    fi
    if ! stax-generate; then
        stax-error-exit "failed to set up stax" 1
    fi
    stax-message "$STAX_NAME" "NAME"
    if ! stax-config; then
        stax-error-exit "failed to generate stax config" 1
    fi
    if ! $jq . "$template_path" >/dev/null; then
        stax-destroy-files
        stax-error-exit "template $template_path failed jq validation, see error above" 1
    fi
    if ! stax-create-key; then
        stax-destroy-files
        stax-error-exit "failed to create key pair" 1
    fi
    if ! stax-create-bucket; then
        stax-destroy-key
        stax-destroy-files
        stax-error-exit "failed to create bucket" 1
    fi
    # upload template to s3 to have bigger size limits
    if ! stax-upload-template "$template_path"; then
        stax-destroy-bucket
        stax-destroy-key
        stax-destroy-files
        stax-error-exit "failed to upload template to s3" 1
    fi
    if ! stax-validate-template; then
        stax-destroy-bucket
        stax-destroy-key
        stax-destroy-files
        stax-error-exit "failed to validate template" 1
    fi
    stax-message "  uploading vpc assets"
    for f in assets/vpc/*; do
        if ! aws s3 cp "$f" "s3://$STAX_NAME/" > /dev/null; then
            stax-error "failed to upload file $f to bucket $STAX_NAME"
            stax-destroy-bucket
            stax-destroy-key
            stax-destroy-files
            stax-error-exit "asset upload failed" 1
        fi
    done
    stax-message "  vpc assets uploaded"
    stax-message "  creating stax in aws"
    # add --tags
    if ! aws cloudformation create-stack \
        --stack-name "$STAX_NAME" \
        --template-url "$STAX_TEMPLATE_URL" \
        --parameters "$(<$STAX_PARAMS)" \
        --capabilities CAPABILITY_IAM > /dev/null
    then
        stax-error "creation failed, cleaning up"
        stax-destroy-bucket
        stax-destroy-key
        stax-destroy-files
        stax-error-exit "creation failed, exiting" 1
    fi
    if ! echo $STAX_NAME > $STAX_NAME_FILE; then
        stax-error "failed to create STAX_NAME_FILE: echo $STAX_NAME > $STAX_NAME_FILE"
        stax-error-exit "stax will not be able to function without it" 1
    fi
    # new 'audit' functionality, save names and create date of stax you've created
    # if useful, we could save this to S3: and make it persist (well sure, uh, or the fax)
    if mkdir -p "$STAX_DIR/audit/$STAX_NAME"; then
        touch "$STAX_DIR/audit/$STAX_NAME/$(date +'%Y%m%d-%H%M%S')-created"
    else
        stax-error "failed to create audit directory: $STAX_DIR/audit/$STAX_NAME"
        stax-error "please create the audit directory yourself"
    fi
    stax-message "  stax creation complete"
}

stax-ssh-config(){
    stax-message "creating ssh_config"
    STAX_SSH_CONFIG="$STAX_DIR/$STAX_NAME.ssh_config"
    gwhosts="$STAX_DIR/$STAX_NAME.gateway_hosts"
    shosts="$STAX_DIR/$STAX_NAME.service_hosts"
    if [[ ! -f $gwhosts ]]; then
        stax-error "missing gateway host file: $gwhosts"
        return 10
    fi
    if [[ ! -f $shosts ]]; then
        stax-error "missing service host file: $shosts"
        return 10
    fi
    stax-message "  writing $STAX_SSH_CONFIG"
    cat > "$STAX_SSH_CONFIG" <<EOF
ForwardAgent yes
ForwardX11 no
UserKnownHostsFile /dev/null
StrictHostKeyChecking no
ServerAliveInterval 60
ServerAliveCountMax 30
TCPKeepAlive no
IdentityFile $STAX_PRIV_KEY

Host jump
  User ec2-user
  HostName $STAX_PUB_IP
EOF
    if [[ $jump ]]; then
        # when jumping through their jump box, use their ssh_config
        cat >> "$STAX_SSH_CONFIG" <<EOF
  ProxyCommand ssh -q -A -x -o ServerAliveInterval=60 -o ServerAliveCountMax=30 -o TCPKeepAlive=no -W %h:%p $jump
EOF
    fi
    gi=
    for gip in $(<"$gwhosts"); do
        cat >> "$STAX_SSH_CONFIG" <<EOF

Host gateway$gi
  User core
  HostName $gip
  ProxyCommand ssh -q -F $STAX_SSH_CONFIG -W %h:%p jump
EOF
        gi=$((gi+1))
    done
    si=
    for sip in $(<"$shosts"); do
        cat >> "$STAX_SSH_CONFIG" <<EOF

Host service$si
  User core
  HostName $sip
  ProxyCommand ssh -q -F $STAX_SSH_CONFIG -W %h:%p jump
EOF
        si=$((si+1))
    done
    stax-message "  created $STAX_SSH_CONFIG"
    SSH_OPTIONS="$SSH_OPTIONS -F $STAX_SSH_CONFIG"
}

# ensure there is a stax
stax-existing(){
    if [[ ! -f $STAX_NAME_FILE ]]; then
        stax-error "no stax defined, use create first"
        return 1
    fi
    # define all the global variables
    STAX_NAME=$(<$STAX_NAME_FILE)
    STAX_DESC="$STAX_DIR/$STAX_NAME.json"
    STAX_PARAMS="$STAX_DIR/$STAX_NAME.params"
    STAX_KEY="$STAX_NAME"
    STAX_PRIV_KEY="$STAX_DIR/$STAX_NAME.pem"
    STAX_PUB_KEY="$STAX_PRIV_KEY.pub"
    STAX_JUMP_FILE="$STAX_DIR/$STAX_NAME.jump"
    STAX_SSH_CONFIG="$STAX_DIR/$STAX_NAME.ssh_config"
    SSH_OPTIONS="$SSH_OPTIONS -F $STAX_SSH_CONFIG"
}

# save the description of the stax to a file
stax-describe(){
    stax-message "describe stax"
    if [[ ! $STAX_NAME ]]; then
        stax-error "cannot call stax-describe with STAX_NAME undefined"
        return 10
    fi
    stax-message "$STAX_NAME" "NAME"
    stax-message "  querying aws"
    STAX_DESC="$STAX_DIR/$STAX_NAME.json"
    if ! aws --output json cloudformation describe-stacks --stack-name "$STAX_NAME" > "$STAX_DESC"; then
        stax-error-message "failed to get stax information for $STAX_NAME from aws"
        return 1
    fi
    stax-message "  query complete"
    stax-message "  see $STAX_DESC for details"
}

# ensure stax creation is complete
stax-complete(){
    wait="$1"
    stax-message "checking if stax build is complete"
    while :; do
        if ! stax-describe; then
            stax-error "unable to get information about stax $STAX_NAME"
            return 1
        fi
        status=$($jq --raw-output '.Stacks[].StackStatus' "$STAX_DESC")
        if [[ $status == CREATE_COMPLETE ]]; then
            break
        elif [[ $status != CREATE_IN_PROGRESS ]]; then
            stax-error "it appears the build failed: $status"
            stax-error "stax $STAX_NAME will be destroyed"
            stax-destroy
            return 1
        fi
        stax-message "  stax build not complete: $status"
        if [[ $wait ]]; then
            stax-message "  waiting for build to complete..."
        else
            return 1
        fi
        sleep 30
    done
    stax-message "  stack $STAX_NAME build complete"
}

stax-list(){
    stax-message "list currently running stax"
    stax-message "  querying aws "
    # list running stax
    if ! aws --output json cloudformation list-stacks --stack-status-filter CREATE_COMPLETE | $jq --raw-output '.StackSummaries[].StackName' | grep '^vpc-stax-' > /tmp/run.list; then
        stax-error "  aws query failed"
        return 1
    fi
    running_stax=`cat /tmp/run.list | wc -l`
    stax-message "  $running_stax running stax"
    stax-message "    (the * denotes one handled by local node)"
    echo "{"
    ls -1 "$STAX_DIR/audit" > /tmp/hist.list
    # put a * by one if it was launched from here
    for f in $(cat /tmp/run.list); do
        echo -n $f && if grep $f /tmp/hist.list > /dev/null; then echo " *" && owned_stax=$f ; else echo; fi
    done
    #    rm -f /tmp/hist.list /tmp/run.list
    echo "}"
    stax-message "list currently running ec2 instances"
    stax-message "  querying aws "
    running_ec2=`aws ec2 describe-instances --filter Name="instance-state-code",Values="16" | grep "\"Instances\"\:" | wc -l`
    stax-message "  $running_ec2 running ec2 instances"
}

stax-services(){
    stax-message "services that stax can run on the cluster"
    echo "{"
    ls -1 assets/services/*.service | cut -d"/" -f3 | cut -d"." -f1
    echo "}"
}

stax-start-service(){
    if [ -z "$1" ]; then
        stax-error "you must provide a service name, exiting"
        return 10
    fi
    service="$1"
    service_file="assets/services/$service.service"
    service_basename=${service_file##*/}
    if [[ ! -f $service_file ]]; then
        stax-error "unknown service: $service"
        return 1
    fi
    stax-message "starting $service on the stax service cluster"
    stax-message "  copying $service_file to service docker host"
    scp_cmd="scp $SSH_OPTIONS $service_file service:$service_basename"
    if ! $scp_cmd; then
        stax-error "failed to copy service file to service docker host: $scp_cmd"
        return 1
    fi
    stax-message "  submitting service $service to fleet"
    submit_cmd="ssh $SSH_OPTIONS service fleetctl submit $service_basename"
    if ! $submit_cmd; then
        stax-error "failed to submit service to docker host: $submit_cmd"
        return 1
    fi
    stax-message "  starting service $service in fleet"
    start_cmd="ssh $SSH_OPTIONS service fleetctl start $service_basename"
    if ! $start_cmd; then
        stax-error "failed to start service to docker host: $start_cmd"
        return 1
    fi
    touch "$STAX_DIR/audit/$STAX_NAME/$(date +'%Y%m%d-%H%M%S')-fleetctl-started-service-$service"
}

stax-fleetstats(){
    stax-message "status from fleetctl on the service cluster"
    for fleet_cmd in "list-machines" "list-units" "list-unit-files"; do
        stax-message "  running $fleet_cmd"
        if ! stax-connect service fleetctl $fleet_cmd; then
            stax-error "command failed on service host: fleetctl $fleet_cmd"
            return 1
        fi
    done
}

stax-descauto(){
    stax-message "describe autoscaling groups"
    stax-message "  querying aws for autoscaling policies"
    if ! aws --output json autoscaling describe-auto-scaling-groups | grep "arn:aws:autoscaling" | grep `cat $STAX_NAME_FILE` | cut -d"/" -f2 | cut -d"\"" -f1 > /tmp/asg; then
        rm -f /tmp/asg
        stax-error-exit "failed to get autoscaling policies" 1
    fi
    if ! aws --output json autoscaling describe-policies --auto-scaling-group-name `cat /tmp/asg`; then
        rm -f /tmp/asg
        stax-error-exit "failed to get information about autoscaling policies" 1
    fi
    rm -f /tmp/asg
}

stax-history(){
    stax-message "history"
    stax-message "  recently created and destoryed stax"
    echo "{"
    cd $STAX_DIR; cd ..
    ls -1R "run/audit" | cut -d"/" -f3 | sed -e "1d"
    echo "}"
}

stax-jumpip(){
    stax-message "getting public IP (EIP)"
    if [[ ! $STAX_DESC ]]; then
        stax-error "cannot call stax-jumpip without STAX_DESC defined"
        return 10
    fi
    if [[ ! -f $STAX_DESC ]]; then
        stax-error "stax description file not found: $STAX_DESC"
        return 1
    fi
    STAX_JUMP_FILE="$STAX_DIR/$STAX_NAME.jump"
    STAX_PUB_IP=$($jq --raw-output '.Stacks[].Outputs[] | select(.OutputKey=="JumpEIP").OutputValue' "$STAX_DESC")
    stax-message "  public IP (EIP): $STAX_PUB_IP"
    stax-message "  writing to $STAX_JUMP_FILE"
    echo "$STAX_PUB_IP" > "$STAX_JUMP_FILE"
}

stax-motd(){
    stax-message "creating motd"
    now=$(date)
    motd="$STAX_DIR/$STAX_NAME.motd"
    cat > "$motd" <<'EOF'
     _
    | | welcome to the jumpbox
 ___| |_ __ ___  __
/ __| __/ _` \ \/ /
\__ \ || (_| |>  <
|___/\__\__,_/_/\_\

EOF
    cat >> "$motd" <<EOF
Name      $STAX_NAME
Built     $now
EOF
}

stax-popjumpbox(){
    stax-message "setup motd and bashrc on jumpbox"
    stax-message "  pushing motd to jump box"
    motd="$STAX_DIR/$STAX_NAME.motd"
    if [[ ! -f $motd ]]; then
        stax-error "motd file not found: $motd"
        return 10
    fi
    if ! scp $SSH_OPTIONS "$motd" jump:motd > /dev/null; then
        stax-error "failed to copy motd file to jump box"
        return 1
    fi
    stax-message "  pushing bashrc to jump box"
    if ! scp $SSH_OPTIONS assets/stax/bashrc jump:.bashrc > /dev/null; then
        stax-error "failed to copy bashrc file to jump box"
        return 1
    fi
}

stax-getdockerips(){
    stax-message "get gateway and service IPs"
    stax-message "  querying aws for gateway hosts"
    gateway_hosts="$STAX_DIR/$STAX_NAME.gateway_hosts"
    if ! aws --output json ec2 describe-instances | $jq --raw-output ".Reservations[].Instances[] | select(.Tags[].Value==\"gateway-$STAX_NAME\").PrivateIpAddress" > "$gateway_hosts"; then
        stax-error "failed to query aws for gateway instances"
        return 1
    fi
    stax-message "  querying aws for service hosts"
    service_hosts="$STAX_DIR/$STAX_NAME.service_hosts"
    if ! aws --output json ec2 describe-instances | $jq --raw-output ".Reservations[].Instances[] | select(.Tags[].Value==\"service-$STAX_NAME\").PrivateIpAddress" > "$service_hosts"; then
        stax-error "failed to query aws for service instances"
        return 1
    fi
}

stax-ssh-key-add(){
    stax-message "adding private key to ssh-agent"
    if [[ ! $STAX_PRIV_KEY ]]; then
        stax-error "cannot call stax-ssh-key-add when STAX_PRIV_KEY undefined"
        return 10
    fi
    if ! ssh-add "$STAX_PRIV_KEY" > /dev/null 2>&1; then
        stax-error "failed to add private key to ssh-agent: $STAX_PRIV_KEY"
        return 1
    fi
    stax-message "  private key added"
}

stax-ssh-key-remove(){
    stax-message "removing private key from ssh-agent"
    if [[ ! $STAX_PUB_KEY ]]; then
        stax-error "cannot call stax-ssh-key-remove when STAX_PUB_KEY undefined"
        return 10
    fi
    if ! ssh-add -d "$STAX_PUB_KEY" > /dev/null 2>&1; then
        stax-error "failed to remove private key from ssh-agent: $STAX_PUB_KEY"
        stax-error "you will have to remove it yourself"
        return 1
    fi
    stax-message "  private key removed"
}

stax-connect(){
    target="jump"
    if [[ $1 ]]; then
        target="$1"
        shift
        case "$target" in
            jump|gateway*|service*)
                :;;
            *)
                stax-error "unknown connection target: $target"
                return 1
                ;;
        esac
    fi
    # only print message when no command supplied
    if [[ $# == 0 ]]; then
        stax-message "connecting to stax: $target"
    fi
    ssh_cmd="ssh $SSH_OPTIONS $target $@"
    if ! $ssh_cmd; then
        stax-error "ssh command failed: $ssh_cmd"
        return 1
    fi
}

stax-destroy-key(){
    stax-message "destroying key pair"
    if ! stax-ssh-key-remove; then
        stax-error "failed to remove ssh key from ssh-agent, continuing"
    fi
    stax-message "  making sure key $STAX_NAME exists in aws"
    if ! aws ec2 describe-key-pairs --key-names "$STAX_NAME" > /dev/null 2>&1; then
        stax-message "  key $STAX_NAME does not exist in aws"
        return 0
    fi
    stax-message "  deleting $STAX_NAME key from aws"
    status=0
    if ! aws ec2 delete-key-pair --key-name "$STAX_NAME" > /dev/null; then
        stax-error "failed to delete key $STAX_NAME, please remove it manually"
        return 1
    fi
    rm -f $STAX_PUB_KEY $STAX_PRIV_KEY
}

stax-destroy-files(){
    stax-message "destroying local files"
    if [[ ! $STAX_NAME ]]; then
        stax-error "cannot destroy files if STAX_NAME is not defined"
        return 10
    fi
    stax-message "  deleting $STAX_NAME files"
    rm -f "$STAX_DIR/$STAX_NAME"* "$STAX_NAME_FILE" > /dev/null
}

stax-destroy-bucket(){
    stax-message "removing s3 bucket"
    if [[ ! $STAX_NAME ]]; then
        stax-error "cannot destroy bucket if STAX_NAME is not defined"
        return 10
    fi
    stax-message "  making sure bucket $STAX_NAME exists in aws"
    if ! aws --output json s3api list-buckets | $jq --raw-output '.Buckets[].Name' | grep -q "^$STAX_NAME$" > /dev/null 2>&1; then
        stax-error "bucket $STAX_NAME does not exist"
        return 1
    fi
    stax-message "  removing s3 bucket $STAX_NAME"
    if ! aws s3 rb --force "s3://$STAX_NAME" > /dev/null; then
        stax-error "failed to delete 3 bucket $STAX_NAME, please remove it manually"
    fi
}

stax-destroy(){
    stax-message "destroy stax"
    if [[ $YES != "y" ]]; then
        read -p "${yellow}[ ${cyan}????${yellow} ]${reset}     ok to destroy $STAX_NAME [y/n]? " answer
        if [[ $answer != y ]] ; then
            stax-message "  will not destroy $STAX_NAME"
            return 0
        fi
    fi

    ls -1 $STAX_DIR/audit/$STAX_NAME/*-RDS-created > /tmp/rds.total
    if [ `cat /tmp/rds.total | wc -l` -gt 0 ]; then
        stax-message "this stax also contains an RDS"
            if [[ $YES != "y" ]]; then
                read -p "${yellow}[ ${cyan}????${yellow} ]${reset}     ok to destroy $STAX_NAME-RDS with the $STAX_NAME [y/n]? " answer
                if [[ $answer != y ]] ; then
                    stax-error-exit "  will not destroy $STAX_NAME-RDS, can't destroy one without the other, existing" 2
                else
                    stax-destroy-rds
                fi
            fi
    fi
    rm /tmp/rds.total

    stax-message "destroying $STAX_NAME stax"
    if ! aws cloudformation delete-stack --stack-name "$STAX_NAME" > /dev/null; then
        stax-error "stax destroy of $STAX_NAME failed"
        stax-error "you will need to clean up the stack, key, bucket, and files"
        return 1
    fi
    stax-message "  destroy started successfully"
    touch "$STAX_DIR/audit/$STAX_NAME/$(date +'%Y%m%d-%H%M%S')-destroyed"
    status=0
    if ! stax-destroy-bucket; then
        status=2
    fi
    if ! stax-destroy-key; then
        status=2
    fi
    if ! stax-destroy-files; then
        status=2
    fi
    return $status
}

# bootstrap: set up STAX_NAME and config file
stax-generate(){
    stax_words="assets/stax/words"
    NUMW=$(wc -l < $stax_words)
    RANDOM_NAM=$(head -$((${RANDOM} % ${NUMW} + 1)) $stax_words | tail -1)
    RANDOM_NUM=$((RANDOM%99999+10001))
    STAX_NAME="vpc-$STAX_PRE_NAME-$RANDOM_NUM-$RANDOM_NAM"
}

# generate parameters file
stax-config(){
    # verify config is filled out
    if [[ ! -f $config ]]; then
        stax-error "config file does not exist: $config"
        stax-error "configuration required"
        stax-error "copy example to config directory, configure it and run again."
        stax-error "    $ cp $config.example $config"
        return 1
    fi
    stax-message "creating parameter file"
    # initialize sed command
    sed="sed -e s/@KEY_NAME@/$STAX_NAME/"
    # check what subsitutions need to be done
    if grep -q '@OWNER@' "$config" > /dev/null 2>&1; then
        owner="$(id -u -n)"
        if [[ -z $owner ]]; then
            stax-error "failed to determine user"
            return 1
        fi
        sed="$sed -e s/@OWNER@/$owner/"
    fi
    external_cidr="$(curl -s http://icanhazip.com)/32"
    if [[ -z $external_cidr ]]; then
        stax-error "failed to get external IP address for local machine"
    fi
    if grep -q '@HTTP_FROM@' "$config" > /dev/null 2>&1; then
        if [[ ! $external_cidr ]]; then
            stax-error "config requests replacement for @HTTP_FROM@ but unable to determine external IP"
            return 1
        fi
        sed="$sed -e s|@HTTP_FROM@|$external_cidr|"
    fi
    if grep -q '@SSH_FROM@' "$config" > /dev/null 2>&1; then
        if [[ $jump ]]; then
            ssh_from="$jump/32"
        else
            if [[ ! $external_cidr ]]; then
                stax-error "config requests replacement for @SSH_FROM@ but unable to determine external IP"
                return 1
            fi
            ssh_from="$external_cidr"
        fi
        sed="$sed -e s|@SSH_FROM@|$ssh_from|"
    fi
    if grep -q '@DISCOVERY_URL@' "$config" > /dev/null 2>&1; then
        DISCOVERY_URL="$(curl -s http://discovery.etcd.io/new)"
        if [[ -z $DISCOVERY_URL || $DISCOVERY_URL == 'Unable to generate token' ]]; then
            stax-error "failed to get discovery URL"
            return 1
        fi
        sed="$sed -e s|@DISCOVERY_URL@|$DISCOVERY_URL|"
    fi
    STAX_PARAMS="$STAX_DIR/$STAX_NAME.params"
    if ! $sed "$config" > "$STAX_PARAMS"; then
        stax-error "sed failed to replace elements in $config: $sed"
        return 1
    fi
}

# generate RDS parameters file
stax-rds-config(){
    # verify config is filled out
    if [[ ! -f $config_rds ]]; then
        stax-error "config file does not exist: $config_rds"
        stax-error "configuration required"
        stax-error "copy example to config directory, configure it and run again."
        stax-error "    $ cp $config_rds.example $config_rds"
        return 1
    fi
    stax-message "creating parameter file"
    vpc_id=`cat $STAX_DIR/$STAX_NAME.vpc`
    # initialize sed command
    sed="sed -e s/@VPC_ID@/$vpc_id/"
    STAX_RDS_PARAMS="$STAX_DIR/$STAX_NAME.rdsparams"
    if ! $sed "$config_rds" > "$STAX_RDS_PARAMS"; then
        stax-error "sed failed to replace elements in $config: $sed"
        return 1
    fi
}

# automated test
stax-test(){
    stax-message "running stax test"
    if [[ ! $1 ]]; then
        stax-error-exit "stax-test takes the template path as an argument" 10
    fi
    template_path="$1"
    stax-message "  create dummy parameter config"
    user=$(id -u -n)
    config="/tmp/test-config-$user-$$-$RANDOM.json"
    if ! cat > "$config" <<EOF
[
  { "ParameterKey": "App",                 "ParameterValue": "Stax Auto Test" },
  { "ParameterKey": "Group",               "ParameterValue": "ITSA" },
  { "ParameterKey": "CostCenter",          "ParameterValue": "5180-9130-SLR74733" },
  { "ParameterKey": "DockerInstanceType",  "ParameterValue": "t2.micro" },
  { "ParameterKey": "Owner",               "ParameterValue": "@OWNER@" },
  { "ParameterKey": "KeyName",             "ParameterValue": "@KEY_NAME@" },
  { "ParameterKey": "AllowSSHFrom",        "ParameterValue": "@SSH_FROM@" },
  { "ParameterKey": "AllowHTTPFrom",       "ParameterValue": "@HTTP_FROM@" },
  { "ParameterKey": "DiscoveryURL",        "ParameterValue": "@DISCOVERY_URL@" }
]
EOF
    then
        stax-error "failed to create test config file"
        return 1
    fi
    # loop through the setup commands
    for cmd in \
        "stax-create $template_path" \
        "rm -f $config" \
        "stax-existing" \
        "stax-motd" \
        "stax-complete 1" \
        "stax-jumpip" \
        "stax-getdockerips" \
        "stax-ssh-config"
    do
        if ! $cmd; then
            stax-error "stax test failed: $cmd"
            return 1
        fi
    done
    stax-popjumpbox
    status=0
    stax-message "  connecting to jump box and running hostname"
    if ! stax-connect jump hostname; then
        stax-error "failed to run hostname on jump box"
        status=$((status+1))
    fi
    stax-message "  giving docker containers some time to spin up"
    sleep 300
    for target in gateway service; do
        for docker_cmd in images ps; do
            stax-message "  running docker $docker_cmd on $target"
            if ! stax-connect $target docker $docker_cmd; then
                stax-error "failed to run docker $docker_cmd on $target"
                status=$((status+1))
            fi
        done
    done
    stax-message "  giving etcd and fleet some time to cluster"
    sleep 120
    stax-message "  getting etcd version"
    if ! stax-connect service curl --silent --location http://localhost:4001/version; then
        echo ""
        stax-error "failed to get etcd version"
        status=$((status+1))
    fi
    echo ""
    stax-message "  listing machines in fleet cluster"
    if ! stax-connect service fleetctl list-machines; then
        stax-error "failed to run fleetctl list-machines on service"
        status=$((status+1))
    fi
    stax-message "  giving consul some time to cluster"
    sleep 120
    stax-message "  getting consul cluster members"
    if ! stax-connect gateway docker exec consul consul members; then
        stax-error "failed to run consul members on gateway"
        status=$((status+1))
    fi
    if ! stax-connect service docker exec consul curl --silent --location http://localhost:8500/v1/catalog/nodes; then
        echo ""
        stax-error "failed to curl consul members on service"
        status=$((status+1))
    fi
    echo ""

    # start httpbin
    # curl ELB/httpbin/get

    # do not prompt for deleting if all tests were successful
    if [[ $status == 0 ]]; then
        YES="y"
    else
        stax-error "some tests failed, see above for details"
        stax-error "you can troubleshoot using the following commands:"
        stax-error "  $ ./stax connect HOST systemctl status [-l] SERVICE"
        stax-error "  $ ./stax connect HOST journalctl -b -u SERVICE"
        stax-error "where HOST is gateway or service and SERVICE is etcd, fleet, consul, etc."
    fi
    if ! stax-destroy; then
        stax-error "failed to destroy the stack, you will need to clean up"
        status=$((status+1))
    fi

    return $status
}

# process positional parameters
config="config/config.json"
config_rds="config/rds.json"
jump=
template="templates/vpc-default.json"
template_default="$template"
sub_cmd=
sub_cmd_args=
prev_arg=
for arg
do
    if test -n "$prev_arg"; then
        eval "$prev_arg=\$arg"
        prev_arg=
        continue
    fi

    case "$arg" in
        -*=*) optarg=`echo "$arg" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
        *) optarg= ;;
    esac

    case "$arg" in
        -c | --config | --confi | --conf | --con | --co | --c)
            prev_arg=config
            ;;

        --config=* | --confi=* | --conf=* | --con=* | --co=* | --c=*)
            config="$optarg"
            ;;

        -d | --debug | --debu | --deb | --de | -d)
            DEBUG="ON"
            ;;

        -h | --help | --hel | --he | --h)
            stax-usage
            exit 0;;

        -j | --jump | --jum | --ju | --j)
            prev_arg=jump
            ;;

        --jump=* | --jum=* | --ju=* | --j=*)
            jump="$optarg"
            ;;

        -t | --template | --templat | --templa | --templ | --temp | --tem | --te | --t)
            prev_arg=template
            ;;

        --template=* | --templat=* | --templa=* | --templ=* | --temp=* | --tem=* | --te=* | --t=*)
            template="$optarg"
            ;;

        -v | --version | --versio | --versi | --vers | --ver | --ve | --v)
            echo "$pkg $version"
            exit 0;;

        -y | --yes | --ye | --y)
            YES="y"
            ;;

        -*)
            if [[ "$sub_cmd_args" ]]; then
                sub_cmd_args="$sub_cmd_args $arg"
            else
                echo "$pkg: unknown option: $arg"
                echo "$pkg: Try '$pkg --help' for help."
                exit 1
            fi
            ;;

        *)
            if [[ -z $sub_cmd ]]; then
                sub_cmd="$arg"
            elif [[ -z $sub_cmd_args ]]; then
                sub_cmd_args="$arg"
            else
                sub_cmd_args="$sub_cmd_args $arg"
            fi
            ;;

    esac
done

# make sure a command was provided
if [[ -z $sub_cmd ]]; then
    stax-usage
    exit 2
fi

stax-logger "WARN: ---- stax (tag `git log | head -n1 | cut -d " " -f2`) starting ----"

# generic setup
stax-logo
stax-preflight

# determine which subcommand to run
if [ "$DEBUG" == "ON" ]; then echo "----- DEBUG :::: $sub_cmd $sub_cmd_args -----"; fi
case "$sub_cmd" in
    connect)
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-complete; then
            stax-error-exit "stax build not complete" 1
        fi
        if [[ ! -f $STAX_JUMP_FILE ]]; then
            stax-jumpip
            if ! stax-getdockerips; then
                exit 1
            fi
            if ! stax-ssh-config; then
                exit 1
            fi
            stax-popjumpbox
        fi
        STAX_PUB_IP=$(<$STAX_JUMP_FILE)
        if ! stax-connect $sub_cmd_args; then
            exit 1
        fi
        ;;

    create)
        stax-create "$template"
        if ! stax-existing; then
            stax-error-exit "stax create failed" 1
        fi
        if ! stax-motd; then
            stax-error-exit "failed to create motd file" 1
        fi
        if ! stax-describe; then
            stax-error-exit "failed to get stack information from aws" 1
        fi
        ;;

    desc-auto)
        if ! stax-existing; then
            exit 1
        fi
        stax-descauto
        ;;

    desc*)
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-describe; then
            stax-error-exit "stax describe failed" 1
        fi
        ;;

    destroy)
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-destroy; then
            stax-error-exit "please see above errors and deal with them" 1
        fi
        ;;

    dockerip-update)
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-complete; then
            stax-error-exit "stax build not complete" 1
        fi
        if [[ ! -f $STAX_JUMP_FILE ]]; then
            stax-jumpip
        fi
        STAX_PUB_IP=$(<$STAX_JUMP_FILE)
        if ! stax-getdockerips; then
            stax-error "failed to update docker IPs"
            exit 1
        fi
        if ! stax-ssh-config; then
            stax-error "failed to update ssh config"
            exit 1
        fi
        ;;

    fleet)
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-complete; then
            stax-error-exit "stax build not complete" 1
        fi
        if [ ! -f "$STAX_JUMP_FILE" ]; then
            stax-jumpip
            if ! stax-getdockerips; then
                exit 1
            fi
            if ! stax-ssh-config; then
                exit 1
            fi
            stax-popjumpbox
        fi
        STAX_PUB_IP=$(<$STAX_JUMP_FILE)
        if ! stax-fleetstats; then
            exit 1
        fi
        ;;

    help)
        stax-usage
        ;;

    generate)
        stax-generate-template
        ;;

    history)
        stax-history
        ;;

    list)
        stax-list
        ;;

    services)
        stax-services
        ;;

    start)
        if [[ ! $sub_cmd_args ]]; then
            stax-error "no services listed, available ones are"
            stax-services
            exit 2
        fi
        if ! stax-existing; then
            exit 1
        fi
        if ! stax-complete; then
            stax-error-exit "stax build not complete" 1
        fi
        if [ ! -f "$STAX_JUMP_FILE" ]; then
            stax-jumpip
            if ! stax-getdockerips; then
                exit 1
            fi
            if ! stax-ssh-config; then
                exit 1
            fi
            stax-popjumpbox
        fi
        for service in $sub_cmd_args; do
            if ! stax-start-service "$service"; then
                stax-error-exit "failed to start service: $service" 1
            fi
        done
        stax-message "waiting for services to start"
        sleep 20
        if ! stax-fleetstats; then
            exit 1
        fi
        ;;

    add)
        if ! stax-existing; then
            stax-error "no stax defined, use create first."
            exit 1
        fi
        if [[ $template == $template_default ]]; then
            stax-error "you must supply a --template argument when calling add"
            exit 1
        fi
        if ! stax-complete; then
            stax-error-exit "stax build not complete" 1
        fi
        stax-add "$template"
        ;;

    test)
        if ! stax-test "$template"; then
            stax-error "test failed, please delete stack yourself"
            exit 1
        fi
        ;;

    validate)
        if ! stax-validate "$template"; then
            stax-error "template validation failed"
            exit 1
        fi
        ;;

    *)
        stax-error "unknown stax command: $sub_cmd"
        stax-usage
        exit 2
        ;;

esac

exit 0
